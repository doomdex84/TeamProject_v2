<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>Povi</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root {
        --orange: #ff8a00;
        --pink: #ff9acb;
        --blue: #19b5fe;
        --text: #222;
        --muted: #888;
        --bg: #fafbfc;
      }
      * {
        box-sizing: border-box;
      }
      html {
        height: 100%;
      }

      /* ✅ DevTools/스크롤바로 인한 레이아웃 밀림 방지 */
      body {
        margin: 0;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica,
          Arial, "Apple SD Gothic Neo", "Noto Sans KR", sans-serif;
        background: var(--bg);
        color: var(--text);
        overflow-y: scroll; /* 항상 스크롤바 공간 예약 */
        scrollbar-gutter: stable; /* 크롬/엣지 등 지원 */
        min-height: 100%;
      }

      /* === 레이아웃 === */
      .page {
        display: grid;
        grid-template-columns: 1fr 6px 1.2fr; /* 왼쪽 / 구분선 / 오른쪽 */
        column-gap: 0;
        min-height: 100vh;
        align-items: start; /* 각 칼럼 상단 정렬 */
      }
      .left,
      .right {
        padding: 24px;
      }

      /* 가운데 구분선 실제 DOM 요소 */
      .divider {
        background: #eef3f8;
        width: 6px;
        height: 100%;
        border-radius: 6px;
      }

      /* === 카드(테두리 제거 버전) === */
      .panel {
        background: #fff;
        border: none; /* 테두리 제거 */
        border-radius: 16px;
        padding: 18px;
      }
      .panel h2 {
        margin: 0 0 12px;
        color: var(--orange);
        font-weight: 800;
        font-size: 20px;
      }

      .panel-pink {
        background: #fff;
        border: none; /* 테두리 제거 */
        border-radius: 16px;
        padding: 18px;
        /* ✅ 요구: 분석 섹션을 아래로 확실히 내리기 */
        margin-top: 260px; /* (데스크톱) 충분히 떨어뜨림 */
        min-height: 260px;
        display: flex;
        flex-direction: column;
      }
      .panel-pink h2 {
        margin: 0 0 12px;
        color: #ff78bd;
        font-weight: 800;
        font-size: 20px;
      }

      /* 오른쪽 이미지 결과 카드 */
      .image-panel {
        background: #fff;
        border: none; /* 테두리 제거 */
        border-radius: 16px;
        padding: 18px;
        min-height: calc(100vh - 48px);
        display: flex;
        flex-direction: column;
      }
      .image-panel h2 {
        margin: 0 0 8px;
        color: #1aa3e0;
        font-size: 20px;
        font-weight: 800;
      }
      .image-wrap {
        flex: 1;
        display: grid;
        place-items: center;
        border-radius: 12px;
        background: #f5fbff;
        overflow: hidden;
      }
      .image-wrap img {
        max-width: 100%;
        height: auto;
        display: block;
      }

      /* 기타 UI */
      .row {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
        margin-bottom: 8px;
      }
      .btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: auto;
        padding: 6px 12px;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 600;
        border: 0;
        cursor: pointer;
      }
      .btn-primary {
        background: #111;
        color: #fff;
      }
      .btn-secondary {
        background: #666;
        color: #fff;
      }
      .btn-ghost {
        background: #eee;
        color: #333;
      }
      .btn:disabled {
        opacity: 0.45;
        cursor: not-allowed;
      }
      input[type="file"] {
        display: block;
        width: auto;
        padding: 6px 12px;
        border-radius: 8px;
        background: #111;
        color: #fff;
        border: 0;
        font-size: 14px;
        font-weight: 600;
      }

      .ko-box {
        flex: 1;
        border: 2px dashed #bbb;
        border-radius: 12px;
        color: #d45a9e;
        padding: 16px;
        line-height: 1.6;
        white-space: pre-wrap;
      }
      .wave-box {
        display: none;
        margin-top: 8px;
        border-radius: 12px;
        overflow: hidden;
        background: #111;
        border: 1px dashed #333;
      }
      .audio-box {
        display: none;
        margin-top: 10px;
        background: #fafafa;
        border: 1px dashed #ccc;
        border-radius: 12px;
        padding: 10px;
      }
      .prompt-debug {
        display: none;
      }
      .section-title {
        display: flex;
        align-items: baseline; /* 글자 기준선 맞춤 */
        gap: 12px; /* 제목과 문구 간 간격 */
        margin: 0 0 12px;
        flex-wrap: wrap; /* 좁을 때 자동 줄바꿈 */
      }
      .section-title h2 {
        margin: 0;
        color: #ff78bd; /* 기존 핑크 톤 유지 */
        font-weight: 800;
        font-size: 20px;
      }
      .section-title .section-note {
        margin: 0;
        font-size: 14px;
        color: #9aa0a6; /* 은은한 회색 */
        font-weight: 600;
      }

      /* 반응형 */
      @media (max-width: 980px) {
        .page {
          grid-template-columns: 1fr;
        }
        .divider {
          display: none;
        }
        .panel-pink {
          margin-top: 32px;
        } /* 모바일에서는 간격 축소 */
      }
    </style>
  </head>
  <body>
    <div class="page">
      <!-- 왼쪽 -->
      <div class="left">
        <section class="panel">
          <h2>녹음 / 분석</h2>

          <!-- 1행: 녹음/정지/다시녹음/미리듣기 -->
          <div class="row">
            <button id="btnRec" class="btn btn-primary">● 녹음 시작</button>
            <button id="btnStop" class="btn btn-secondary" disabled>
              ■ 녹음 정지
            </button>
            <button id="btnReRec" class="btn btn-ghost" disabled>
              ↺ 다시 녹음
            </button>
            <button id="btnPreview" class="btn btn-ghost" disabled>
              ▶ 미리 듣기
            </button>
            <small id="recStatus" style="margin-left: 4px; color: #777"
              >대기 중</small
            >
          </div>

          <!-- 2행: 파일 선택 + 분석 -->
          <div class="row" style="margin-bottom: 0">
            <input type="file" id="file" accept="audio/*" />
            <button id="btnAnalyze" class="btn btn-ghost" disabled>
              분석하기
            </button>
          </div>

          <!-- 녹음 중 파형 -->
          <div class="wave-box" id="waveBox">
            <canvas
              id="waveform"
              height="120"
              style="width: 100%; height: 120px; display: block"
            ></canvas>
          </div>

          <!-- 미리듣기 오디오 -->
          <div class="audio-box" id="audioBox">
            <audio
              id="player"
              controls
              playsinline
              preload="auto"
              style="width: 100%"
            ></audio>
          </div>
        </section>

        <!-- ✅ 분석 후 설명: 아래로 충분히 내림 -->
        <section class="panel-pink">
          <div class="section-title">
            <h2>분석 후 설명</h2>
            <h5 class="section-note">
              ⚠️ 재미용이니 너무 진지하게 받아들이지 마시오.
            </h5>
          </div>
          <div id="koBox" class="ko-box">분석 결과가 여기에 표시됩니다.</div>
          <div class="row" style="margin-top: 12px">
            <button id="btnToImage" class="btn btn-primary" disabled>
              이미지 생성
            </button>
          </div>
        </section>
      </div>

      <!-- ✅ 가운데 실제 구분선 요소 -->
      <div class="divider" aria-hidden="true"></div>

      <!-- 오른쪽 -->
      <div class="right">
        <section class="image-panel">
          <h2>이미지 결과</h2>
          <div class="image-wrap" id="imageWrap">
            <span style="color: #8ad2ff">아직 생성된 이미지가 없습니다</span>
          </div>
          <div id="promptDebug" class="prompt-debug"></div>
        </section>
      </div>
    </div>

    <script>
      const API_BASE = location.port === "5500" ? "http://127.0.0.1:8000" : "";

      // ===== 상태 & 요소 =====
      let mediaRecorder,
        chunks = [];
      let currentBlob = null,
        lastBlobUrl = null,
        fileBlobUrl = null;
      let lastResult = null;
      let audioCtx, analyser, sourceNode, dataArray, animationId, gStream;

      // 버튼/요소
      const btnRec = document.getElementById("btnRec");
      const btnStop = document.getElementById("btnStop");
      const btnReRec = document.getElementById("btnReRec");
      const btnPreview = document.getElementById("btnPreview");
      const btnAnalyze = document.getElementById("btnAnalyze");
      const fileInput = document.getElementById("file");
      const recStatus = document.getElementById("recStatus");

      const waveBox = document.getElementById("waveBox");
      const waveformCanvas = document.getElementById("waveform");
      const canvasCtx = waveformCanvas.getContext("2d");
      const audioBox = document.getElementById("audioBox");
      const player = document.getElementById("player");

      function setStatus(msg) {
        recStatus.textContent = msg;
      }

      // ▶▶ 버튼 핸들러보다 먼저 선언
      function getPreviewSource() {
        if (currentBlob) return { type: "record", blob: currentBlob };
        const f = fileInput.files && fileInput.files[0];
        if (f) return { type: "file", file: f };
        return null;
      }

      function updateActionButtons() {
        const hasRecord = !!currentBlob;
        const hasFile = !!(fileInput.files && fileInput.files[0]);
        const enabled = hasRecord || hasFile;
        btnPreview.disabled = !enabled;
        btnAnalyze.disabled = !enabled;
        btnReRec.disabled = !hasRecord;
      }

      // ===== 장치 자동 선택 =====
      let preferredInputId = null; // audioinput
      let preferredOutputId = null; // audiooutput

      function scoreLabel(label) {
        const L = (label || "").toLowerCase();
        if (/(headset|headphone|ear|airpods)/.test(L)) return 3;
        if (/(usb|external)/.test(L)) return 2;
        if (/(array|realtek|microphone|speaker)/.test(L)) return 1;
        return 0;
      }

      async function pickPreferredDevices() {
        try {
          const tmp = await navigator.mediaDevices.getUserMedia({
            audio: true,
          });
          tmp.getTracks().forEach((t) => t.stop());
        } catch (e) {}
        try {
          const devs = await navigator.mediaDevices.enumerateDevices();
          const inputs = devs
            .filter((d) => d.kind === "audioinput")
            .sort((a, b) => scoreLabel(b.label) - scoreLabel(a.label));
          const outputs = devs
            .filter((d) => d.kind === "audiooutput")
            .sort((a, b) => scoreLabel(b.label) - scoreLabel(a.label));
          preferredInputId = inputs[0]?.deviceId || null;
          preferredOutputId = outputs[0]?.deviceId || null;
        } catch (e) {
          preferredInputId = preferredOutputId = null;
        }
      }
      pickPreferredDevices();

      // ===== 파형 =====
      async function startWaveform(stream) {
        waveBox.style.display = "block";
        waveformCanvas.width = waveformCanvas.clientWidth || 600;
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        await audioCtx.resume();
        analyser = audioCtx.createAnalyser();
        sourceNode = audioCtx.createMediaStreamSource(stream);
        sourceNode.connect(analyser);
        analyser.fftSize = 2048;
        dataArray = new Uint8Array(analyser.fftSize);

        function draw() {
          animationId = requestAnimationFrame(draw);
          analyser.getByteTimeDomainData(dataArray);
          canvasCtx.fillStyle = "#111";
          canvasCtx.fillRect(0, 0, waveformCanvas.width, waveformCanvas.height);
          canvasCtx.lineWidth = 2;
          canvasCtx.strokeStyle = "#ff8a00";
          canvasCtx.beginPath();
          const sliceWidth = waveformCanvas.width / dataArray.length;
          let x = 0;
          for (let i = 0; i < dataArray.length; i++) {
            const y = (dataArray[i] / 128.0) * (waveformCanvas.height / 2);
            if (i === 0) canvasCtx.moveTo(x, y);
            else canvasCtx.lineTo(x, y);
            x += sliceWidth;
          }
          canvasCtx.lineTo(waveformCanvas.width, waveformCanvas.height / 2);
          canvasCtx.stroke();
        }
        draw();
      }
      function stopWaveform() {
        if (animationId) cancelAnimationFrame(animationId);
        if (audioCtx) {
          audioCtx.close();
          audioCtx = null;
        }
        waveBox.style.display = "none";
        canvasCtx.clearRect(0, 0, waveformCanvas.width, waveformCanvas.height);
      }

      // ===== 녹음 제어 =====
      async function startRecording() {
        let constraints = preferredInputId
          ? { audio: { deviceId: { exact: preferredInputId } } }
          : { audio: true };
        try {
          const stream = await navigator.mediaDevices.getUserMedia(constraints);
          return beginRecordingWithStream(stream);
        } catch (e) {
          const fallback = await navigator.mediaDevices.getUserMedia({
            audio: true,
          });
          return beginRecordingWithStream(fallback);
        }
      }

      async function beginRecordingWithStream(stream) {
        gStream = stream;
        chunks = [];
        currentBlob = null;
        if (lastBlobUrl) URL.revokeObjectURL(lastBlobUrl);

        await startWaveform(stream);

        try {
          mediaRecorder = new MediaRecorder(stream);
        } catch (e) {
          alert("이 브라우저에서 녹음이 지원되지 않습니다.");
          return;
        }

        mediaRecorder.ondataavailable = (e) => {
          if (e.data && e.data.size) chunks.push(e.data);
        };
        mediaRecorder.onstop = () => {
          currentBlob = new Blob(chunks, { type: "audio/webm" });
          stopWaveform();
          setStatus("녹음 완료 — 미리 듣기 가능");
          btnStop.disabled = true;
          updateActionButtons();
          try {
            gStream.getTracks().forEach((t) => t.stop());
          } catch {}
          gStream = null;
        };

        mediaRecorder.start(200);
        setStatus("녹음 중…");
        btnStop.disabled = false;
        updateActionButtons();
      }

      btnRec.onclick = startRecording;
      btnStop.onclick = () => {
        if (mediaRecorder && mediaRecorder.state !== "inactive")
          mediaRecorder.stop();
      };

      btnReRec.onclick = () => {
        if (player) {
          player.pause();
          player.removeAttribute("src");
          player.load();
        }
        audioBox.style.display = "none";
        currentBlob = null;
        if (lastBlobUrl) URL.revokeObjectURL(lastBlobUrl);
        lastBlobUrl = null;
        updateActionButtons();
        startRecording();
      };

      // ===== 미리 듣기 =====
      btnPreview.onclick = async () => {
        const src = getPreviewSource();
        if (!src) {
          alert("녹음하거나 파일을 선택하세요.");
          return;
        }
        if (lastBlobUrl) URL.revokeObjectURL(lastBlobUrl);
        if (src.type === "record") {
          lastBlobUrl = URL.createObjectURL(src.blob);
        } else {
          if (fileBlobUrl) URL.revokeObjectURL(fileBlobUrl);
          fileBlobUrl = URL.createObjectURL(src.file);
          lastBlobUrl = fileBlobUrl;
        }
        player.src = lastBlobUrl;

        if (typeof player.setSinkId === "function" && preferredOutputId) {
          try {
            await player.setSinkId(preferredOutputId);
          } catch (e) {}
        }

        audioBox.style.display = "block";
        try {
          await player.play();
          setStatus("미리 듣는 중");
        } catch (e) {
          setStatus("재생 실패: 출력 장치/볼륨을 확인해주세요.");
        }
      };

      // 업로드 변경 시
      fileInput.addEventListener("change", () => {
        if (fileInput.files && fileInput.files[0]) currentBlob = null;
        updateActionButtons();
      });

      // ===== 분석 =====
      async function analyzeCurrent() {
        const src = getPreviewSource();
        if (!src) {
          alert("녹음하거나 파일을 선택하세요.");
          return;
        }
        const fd = new FormData();
        if (src.type === "record") {
          fd.append(
            "file",
            new File([src.blob], "record.webm", { type: "audio/webm" })
          );
        } else {
          fd.append("file", src.file);
        }
        setStatus("분석 중…");
        const r = await fetch(`${API_BASE}/analyze_api`, {
          method: "POST",
          body: fd,
        });
        const raw = await r.json().catch(() => null);
        if (!raw || raw.ok === false) {
          alert(raw?.error || "분석 실패");
          setStatus("대기 중");
          return;
        }

        const payload = raw.result || raw.data || raw;
        const desc =
          payload.ko_explanation ||
          payload.koExplanation ||
          payload.description ||
          "";
        document.getElementById("koBox").textContent =
          (desc || "").trim() || "설명을 생성하지 못했습니다.";

        lastResult = {
          en_prompt:
            payload.en_prompt || payload.enPrompt || payload.prompt || "",
          negative_prompt:
            payload.negative_prompt ||
            payload.negative ||
            payload.negativePrompt ||
            "",
        };
        document.getElementById("btnToImage").disabled = !lastResult.en_prompt;
        setStatus("대기 중");
      }
      btnAnalyze.onclick = analyzeCurrent;

      // ===== 이미지 생성 =====
      document.getElementById("btnToImage").onclick = async () => {
        if (!lastResult?.en_prompt) {
          alert("먼저 분석을 완료하세요.");
          return;
        }
        const wrap = document.getElementById("imageWrap");
        wrap.innerHTML = '<span style="color:#555">이미지 생성 중...</span>';

        try {
          const r = await fetch(`${API_BASE}/image/render`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              prompt: lastResult.en_prompt,
              negativePrompt: lastResult.negative_prompt,
              width: 768,
              height: 768,
            }),
          });

          if (!r.ok) {
            const msg = await r.text().catch(() => "");
            wrap.innerHTML = `<span style="color:red">생성 실패: ${
              msg || r.status
            }</span>`;
            return;
          }

          const j = await r.json().catch(() => null);
          if (!j?.imageUrl) {
            wrap.innerHTML =
              '<span style="color:red">imageUrl이 응답에 없습니다.</span>';
            return;
          }

          wrap.innerHTML = "";
          const img = document.createElement("img");
          img.src = j.imageUrl;
          img.alt = "result";
          wrap.appendChild(img);
        } catch (e) {
          wrap.innerHTML =
            '<span style="color:red">이미지 생성 중 오류가 발생했습니다.</span>';
          console.error(e);
        }
      };
    </script>
  </body>
</html>

